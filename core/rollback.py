"""Rollback Framework (P0.2)

Provides a mechanism to snapshot state and artifacts before an action and
restore them upon failure. This is the cornerstone of the "Reversible"
principle, ranked #1 in the NEXUSMON doctrine.

Responsibilities:
- Create a transaction log for multi-step operations.
- Snapshot relevant state (e.g., database records, config files).
- Snapshot artifacts (e.g., files generated by a mission).
- Provide a `restore` function to revert changes from a transaction.
- Work in conjunction with the artifact vault for storing snapshots.

Core Flow:
1. `begin_transaction()` -> returns a `Transaction` object.
2. `transaction.snapshot_file(path)` or `transaction.snapshot_db_record(model, pk)`.
3. Execute the action.
4. `transaction.commit()` on success.
5. `transaction.rollback()` on failure.
"""

import json
import shutil
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, NamedTuple, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --------------------------------------------------------------------------
# Data Models
# --------------------------------------------------------------------------

class Snapshot(NamedTuple):
    """Represents a snapshot of a single resource (file or data)."""
    resource_type: str  # 'file' or 'data'
    resource_id: str    # File path or a unique identifier for data
    snapshot_path: str  # Path to the stored snapshot in the vault


class Transaction:
    """Manages a collection of snapshots for a single reversible action."""

    def __init__(self, transaction_id: str, vault_path: Path):
        self.transaction_id = transaction_id
        self.vault_path = vault_path
        self.transaction_dir = self.vault_path / self.transaction_id
        self.snapshots: List[Snapshot] = []
        self.committed = False
        self.rolled_back = False
        self.log_content_before_delete: Optional[str] = None

        self.transaction_dir.mkdir(parents=True, exist_ok=True)
        self._write_log("begin")

    def _write_log(self, event: str, metadata: Optional[Dict[str, Any]] = None):
        """Append an event to the transaction's log file."""
        log_file = self.transaction_dir / "transaction.log"
        timestamp = datetime.now(timezone.utc).isoformat()
        log_entry = {"timestamp": timestamp, "event": event, **(metadata or {})}
        with open(log_file, "a") as f:
            f.write(json.dumps(log_entry) + "\n")

    def snapshot_file(self, file_path: Path) -> None:
        """Create a snapshot of a file."""
        if not file_path.exists():
            logging.warning(f"Snapshot request for non-existent file: {file_path}")
            return

        snapshot_id = f"file_{file_path.name}_{datetime.now(timezone.utc).timestamp()}"
        snapshot_target_path = self.transaction_dir / snapshot_id
        
        shutil.copy2(file_path, snapshot_target_path)
        
        snapshot = Snapshot(
            resource_type='file',
            resource_id=str(file_path.resolve()),
            snapshot_path=str(snapshot_target_path.resolve())
        )
        self.snapshots.append(snapshot)
        self._write_log("snapshot_file", {"resource_id": str(file_path.resolve()), "snapshot_path": str(snapshot_target_path.resolve())})

    def commit(self) -> None:
        """Mark the transaction as successful and clean up snapshots."""
        if self.committed or self.rolled_back:
            raise RuntimeError("Transaction has already been finalized.")
        
        self._write_log("commit")
        # In a real system, you might have a retention policy, but for now, we clean up.
        shutil.rmtree(self.transaction_dir)
        self.committed = True
        logging.info(f"Transaction {self.transaction_id} committed.")

    def rollback(self) -> None:
        """Restore all resources from their snapshots."""
        if self.committed or self.rolled_back:
            raise RuntimeError("Transaction has already been finalized.")

        self._write_log("rollback_started")
        logging.info(f"Rolling back transaction {self.transaction_id}...")

        for snapshot in reversed(self.snapshots): # Rollback in reverse order
            try:
                if snapshot.resource_type == 'file':
                    original_path = Path(snapshot.resource_id)
                    snapshot_path = Path(snapshot.snapshot_path)
                    
                    # Restore the file from the snapshot
                    shutil.copy2(snapshot_path, original_path)
                    
                    self._write_log("restore_file", {"snapshot": str(snapshot_path), "target": str(original_path)})
                    logging.info(f"Restored file {original_path} from snapshot.")
                # Add other resource types (like 'data') here in a real implementation
            except Exception as e:
                logging.error(f"Failed to restore snapshot for {snapshot.resource_id}: {e}")
                self._write_log("restore_failed", {"resource_id": snapshot.resource_id, "error": str(e)})
                # Depending on policy, you might want to stop or continue.
                # For now, we continue to attempt to restore other snapshots.

        self._write_log("rollback_finished")
        
        # Store log content before deleting the directory for testing purposes
        log_file = self.transaction_dir / "transaction.log"
        if log_file.exists():
            self.log_content_before_delete = log_file.read_text()

        shutil.rmtree(self.transaction_dir)
        self.rolled_back = True
        logging.info(f"Transaction {self.transaction_id} rolled back.")


class RollbackEngine:
    """The main engine for managing transactions."""

    def __init__(self, vault_dir: str = "data/rollback_vault"):
        self.vault_path = Path(vault_dir)
        self.vault_path.mkdir(parents=True, exist_ok=True)

    def begin_transaction(self) -> Transaction:
        """
        Starts a new transaction.

        Returns:
            A Transaction object to manage snapshots.
        """
        transaction_id = f"txn_{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S%f')}"
        return Transaction(transaction_id, self.vault_path)

# Global instance for easy access
rollback_engine = RollbackEngine()
